##############################################################################
# Copyright 2013 Xilinx Inc. All rights reserved
##############################################################################
namespace eval ::hsi::utils {
}

#
# It will return the software common::version.
# Note: Mostly it is used when some new file need to be generated through HSI
#
proc ::hsi::utils::get_sw_build_version { } {
    set ret [common::version -short]
}

#
# It will return the copyright message along with software common::version
# Note: Mostly it is used when some new file need to be generated through HSI
#
proc ::hsi::utils::get_copyright_msg { } {
    set copyright_str "Copyright (C) 2010-"
    append copyright_str [clock format [clock seconds] -format %Y]
    append copyright_str " Xilinx, Inc. All Rights Reserved."
    append copyright_str "\n"
    append copyright_str "* SPDX-License-Identifier: MIT "
    append copyright_str "\n"
#    append copyright_str "*\n"
#    append copyright_str "*Permission is hereby granted, free of charge, to any person obtaining a copy\n"
#     append copyright_str "*of this software and associated documentation files (the Software), to deal\n"
#     append copyright_str "*in the Software without restriction, including without limitation the rights\n"
#      append copyright_str "*to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
#      append copyright_str "*copies of the Software, and to permit persons to whom the Software is\n" 
#      append copyright_str "*furnished to do so, subject to the following conditions:\n"
#    append copyright_str "*\n"
#    append copyright_str "*The above copyright notice and this permission notice shall be included in\n"
#     append copyright_str "*all copies or substantial portions of the Software.\n"
#    append copyright_str "* \n"
#    append copyright_str "*THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
#     append copyright_str "*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
#      append copyright_str "*FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL \n"
#      append copyright_str "*THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n"
#      append copyright_str "*WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\n"
#       append copyright_str "*OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
#    append copyright_str "*\n"

    return $copyright_str
}
#
# Print standard Xilinx header for .h/.c files
#
proc ::hsi::utils::write_c_header {file_handle  desc} {
    puts $file_handle "
/*******************************************************************
*
* CAUTION: This file is automatically generated by HSI.
* Version: [::hsi::utils::get_sw_build_version]
* DO NOT EDIT.
*
* [::hsi::utils::get_copyright_msg]
* 
* Description: $desc
*
*******************************************************************/
"
}

#
# Print standard Xilinx header for .tcl files
#
proc ::hsi::utils::write_tcl_header {file_handle  desc} {
    puts $file_handle "
# ------------------------------------------------------------------
#
# CAUTION: This file is automatically generated by HSI.
# Version: [::hsi::utils::get_sw_build_version]
# DO NOT EDIT.
#
# [::hsi::utils::get_copyright_msg]
# 
# Description: $desc
#
# ------------------------------------------------------------------
"
}


#
# get the special format for the address parameters which has special string in parameter value. 
#
proc ::hsi::utils::format_addr_string {value param_name} {
   if {[string match *_BASEADDR $param_name] || [string match *_HIGHADDR $param_name] || [string compare -nocase $param_name "C_KIND_OF_INTR"] == 0 } {
       set value [::hsi::utils::format_address_string $value]
   }
   return $value
}

#
# get the hex format string of input value
#
proc ::hsi::utils::format_address_string {value} {
   # remove _ from string
   set value [string map {_ ""} $value]
   # Check to see if value starts with 0b or 0x
   if {[string match -nocase 0b* $value]} {
       set value [::hsi::utils::convert_binary_to_hex $value]
   } else {
       set value [format "0x%08llX" $value]
   }
   return $value
}

#
# Convert a binary number to a hex value.  The binary string must be of the form 0b*.  
# The returned hex string is of the form 0x*
#
proc ::hsi::utils::convert_binary_to_hex {value} {
   # remove _ from string
   set value [string map {_ ""} $value]
   
   if {[regexp -nocase {^0b[01]+$} $value]} {
       set value [format "%032s" [string range $value 2 end]]
       set return_value "0x"
       for {set i 0} {$i < 8} {incr i 1} {
           set substr [string range $value [expr $i * 4] [expr ($i * 4)+3]]
           set char 0
           set val 8
           for {set j 0} {$j < 4} {incr j 1} {
               set char [expr (($val >> $j) * [string range $substr $j $j]) + $char]
           }
           set return_value [format "%s%1X" $return_value $char]
       }
       return $return_value
   } else {
       error "convert_binary_to_hex expects a binary string of the form 0b<binary string>." "" "hsi_error"
       return
   }
}
#
# Convert a binary number to a decimal value.  The binary string must be of the form 0b*.  
#
proc ::hsi::utils::convert_binary_to_decimal { value } {
    if {[string match 0B* $value] || [string match 0b* $value]} {
        # Chop off the 0b
        set tail [string range $value 2 [expr [string length $value]-1]]
        # Pad to 32 bits, because binary scan ignores incomplete words
        set list [split $tail ""]
        for {} {[llength $list] < 32} {} {
            set list [linsert $list 0 0]
        }
        set tail [join $list ""]
        # Convert the remainder back to decimal
        binary scan [binary format "B*" $tail] "I*" value
    }
    return $value
}

#
# Convert a number to binary value. 
# Input number can be either integer or hex
# The returned binary value will be prefixed with 0b
# length of the binary value should be specified 
# e.g. if input value is 2, and length is 5, then return value will be 0b00010
#
proc ::hsi::utils::convert_num_to_binary {value length} {
   if {$length == 0} {
       error "convert_num_to_binary expects lenght to be a positive number" "" "mdt_error"
       return
   }

   # remove _ from string
   set value [string map {_ ""} $value]

   set retval ""
   while {$value > 0} {
   set tval [expr $value + 1]
   set val_by_2 [expr $value/2]
   set tval_by_2 [expr $tval/2]
   if {$val_by_2 == $tval_by_2} {
       # means $val is even
       set retval [format "0%s" $retval]
   } else {
       # means $val is odd
       set retval [format "1%s" $retval]
   }
   set value [expr $value/2]
   }

   while {$length > [string length $retval]} {
   set retval [format "0%s" $retval]
   }

   set retval [format "0b%s" $retval]
   return $retval
}

#
# return  1 if $base_addr > $high_addr
# return  0 if $base_addr = $high_addr
# return -1 if $base_addr < $high_addr
#
proc ::hsi::utils::compare_unsigned_addresses {base_addr base_param high_addr high_param} {

    # convert to hexadecimal format
   set base_addr [::hsi::utils::format_addr_string $base_addr $base_param]
   set high_addr [::hsi::utils::format_addr_string $high_addr $high_param]

   # convert to integer value
   set int_base  [expr int($base_addr)]
   set int_high  [expr int($high_addr)]

   return [::hsi::utils::compare_unsigned_int_values $int_base $int_high]

}

#
# return  1 if $int_base > $int_high
# return  0 if $int_base = $int_high
# return -1 if $int_base < $int_high
#
proc ::hsi::utils::compare_unsigned_int_values {int_base int_high} {

   if {$int_base == $int_high} {

   return 0

   }

   if {($int_base >= 0 && $int_high >= 0) || ($int_base < 0 && $int_high < 0)} {

   if {[expr $int_base > $int_high]} {

       return 1

   } else {

       return -1

       }

   } elseif {$int_base >= 0 && $int_high < 0} {

   return -1

   } elseif {$int_base < 0 && $int_high >= 0} {

   return 1

   } 
}


#
# Put the given hex number in the format specified
# by 'bitwidth', padding or truncating bits as 
# necessary in direction specified by 'direction'
#
proc ::hsi::utils::format_to_hex {value bitwidth direction} {
   set val ""
   # remove _ from string
   set value [string map {_ ""} $value]
   #Strip 0x if given and check for valid hex number.
   set vallen [string length $value]
   if {[regexp -nocase {^0x[0-9a-f]+$} $value]} {
       set val [string range $value 2 [expr {$vallen-1}] ]
       set vallen [expr {$vallen-2}]
   } elseif {[regexp -nocase {^[0-9a-f]+$} $value]} {
       set val $value
   } else {
       error "xconvert_tohex expects a Hex number as a string argument. Invalid Hex number provided." "" "edk_error"
       return
   }
       
   set retval "0x"    
   #format it to given bitwidth
   if {[expr {$vallen < $bitwidth}]} {
       set difflen [expr {$bitwidth - $vallen}]
   if { [string compare -nocase $direction "left"] == 0 } {
           while { $difflen != 0 } {
               append retval 0
               set difflen [expr {$difflen - 1}]
       }
       append retval $val
       return $retval
       } elseif { [string compare -nocase $direction "right"] == 0 } {
       append retval $val
           while { $difflen != 0 } {
   	append retval 0
               set difflen [expr $difflen - 1]
       }
       return $retval
   } else {
           error "Invalid value provided for direction. Allowed values are 'right' and 'left'." "" "edk_error"
       return
   }
   } elseif {[expr {$vallen > $bitwidth}]} {
       set difflen [expr {$vallen - $bitwidth}]
       if { [string compare -nocase $direction "left"] == 0 } {
           append retval [string range $val [expr {$difflen}] [expr {$vallen - 1}]]
           return $retval
   } elseif { [string compare -nocase $direction "right"] == 0 } {
           append retval [string range $val 0 [expr {$bitwidth - 1}]]
           return $retval
   } else {
           error "Invalid value provided for direction. Allowed values are 'right' and 'left'." "" "edk_error"
           return
   }
   } else {
           return $value;
   }
}


#
# Put the given bin number in the format specified
# by 'bitwidth', padding or truncating bits as 
# necessary in direction specified by 'direction'
#
proc ::hsi::utils::format_to_bin {value bitwidth direction} {
   set val ""
   # remove _ from string
   set value [string map {_ ""} $value]
   #Strip 0b if given and check for valid hex number.
   set vallen [string length $value]
   if {[regexp -nocase {^0b[01]+$} $value]} {
   
       set val [string range $value 2 [expr {$vallen-1}] ]
       set vallen [expr {$vallen-2}]
  } elseif {[regexp -nocase {^[01]+$} $value]} {
       set val $value
   } else {
       error "xconvert_tobin expects a binary number as a string argument. Invalid binary number provided." "" "edk_error"
       return
   }
       
   set retval "0b"    
   #format it to given bitwidth
   if {[expr {$vallen < $bitwidth}]} {
       set difflen [expr {$bitwidth - $vallen}]
   if { [string compare -nocase $direction "left"] == 0 } {
           while { $difflen != 0 } {
               append retval 0
               set difflen [expr {$difflen - 1}]
       }
       append retval $val
       return $retval
       } elseif { [string compare -nocase $direction "right"] == 0 } {
       append retval $val
           while { $difflen != 0 } {
   	append retval 0
               set difflen [expr $difflen - 1]
       }
       return $retval
   } else {
           error "Invalid value provided for direction. Allowed values are 'right' and 'left'." "" "edk_error"
       return
   }
   } elseif {[expr {$vallen > $bitwidth}]} {
       set difflen [expr {$vallen - $bitwidth}]
       if { [string compare -nocase $direction "left"] == 0 } {
           append retval [string range $val [expr {$difflen}] [expr {$vallen - 1}]]
           return $retval
   } elseif { [string compare -nocase $direction "right"] == 0 } {
           append retval [string range $val 0 [expr {$bitwidth - 1}]]
           return $retval
   } else {
           error "Invalid value provided for direction. Allowed values are 'right' and 'left'." "" "edk_error"
           return
   }
   } else {
           return $value;
   }
}
    
#
# Procedure to get the nameofexecutable. This is similar to 
# Tcl's built-in info nameofexecutable, but it returns the 
# exact name of executable instead of the entire path.
#
proc ::hsi::utils::get_nameofexecutable { } {
   set command [info nameofexecutable]
   set pi_cmd [join [split $command "\\"] "/"]
   set exec_cmd [lindex [split $pi_cmd "/"] end]
   set final_exec [lindex [split $exec_cmd .] 0]
   return $final_exec
}

#
# Procedure to determine the host os platform
# Possible Return values: lnx, lnx64, win, win64
#
proc ::hsi::utils::get_hostos_platform { } {
   global tcl_platform env tcl_library
   set plat_os $env(RDI_PLATFORM)
   return $plat_os
}

#
# Procedure to determine the executable suffix
# Possible Return values: 
#          "exe"             on windows
#          "" (empty-string) on linux
#
proc ::hsi::utils::get_hostos_exec_suffix { } {
   global tcl_platform env tcl_library

   switch -glob $tcl_platform(os) {
   "Windows*" {
       set suffix "exe"
   }
   "Linux" {
       set suffix ""
   }
   default {
       error "Unsupport OS\n" "" "mdt_error"
   }
   }

   return $suffix
}

#
# Procedure to determine the executable suffix
# Possible Return values: 
#          "dll"  on windows
#          "so"   on linux
#
proc ::hsi::utils::get_hostos_sharedlib_suffix { } {
   global tcl_platform env tcl_library

   switch -glob $tcl_platform(os) {
   "Windows*" {
       set suffix "dll"
   }
   "Linux" {
       set suffix "so"
   }
   default {
       error "Unsupport OS\n" "" "mdt_error"
   }
   }

   return $suffix
}

#
# Procedure to find file within a list of given 
# directories. The path provided should be
# relative with respect to the input directories
#
proc ::hsi::utils::find_file_in_dirs { dirlist relative_filepath } {
   #puts "$dirlist\n"
   foreach dir $dirlist {
   set filepath [format "%s/%s" $dir $relative_filepath]
   if { [file exists $filepath] } {
       return $filepath
   }
   }
   ## file not found in any directory
   return ""
}

#
# Procedure to locate a specific file within Xilinx
# tool install. The procedure takes relative path
# with respect to the install area
#
proc ::hsi::utils::find_file_in_xilinx_install { relative_filepath } {
   set dirlist ""

   ## $XILINX can be a list of directories
   if [ info exists ::env(XILINX) ] {
   set xildirs ""
   global tcl_platform env tcl_library
   switch -glob $tcl_platform(os) {
       "Windows*" {
            set xildirs [split $::env(XILINX) ";"]
       }
       "Linux" {
            set xildirs [split $::env(XILINX) ":"]
       }
       default {
            error "Unsupport OS\n" "" "mdt_error"
       }
   }
   foreach xildir $xildirs {
       lappend dirlist $xildir
   }
   } 
   return [::hsi::utils::find_file_in_dirs $dirlist $relative_filepath]
}

#
# Procedure to dynamically load a DLL into Tcl interpreter
# This procedure searches for DLLs in the
# $MYXILINX, $XILINX_EDK, and $XILINX directories
#
proc ::hsi::utils::load_xilinx_library { libname } {
   global tcl_platform env tcl_library

   set plat_os [::hsi::utils::get_hostos_platform]
   set libfile [format "%s.%s" $libname [::hsi::utils::get_hostos_sharedlib_suffix]]

   set lib_relative_path [format "lib/%s/%s/" $plat_os $libfile]
   set lib_full_path [ ::hsi::utils::find_file_in_xilinx_install $lib_relative_path ]
   if { [string length $lib_full_path] == 0 } {
       set lib_relative_path [format "bin/%s/%s/" $plat_os $libfile]
       set lib_full_path [ ::hsi::utils::find_file_in_xilinx_install $lib_relative_path ]
       if { [string length $lib_full_path] == 0 } {
           error "Library $lib_relative_path not found" "" "mdt_error"
       }
    }

   if { [catch {load $lib_full_path} err_msg] } {
       error " $err_msg\n" "" "mdt_error"
   }
}

#
# proc to convert / to _ in xparameter entries 
#
proc ::hsi::utils::format_xparam_name {param_name} {
  set xparam_name [string map { "/" "_" } $param_name]
  return $xparam_name
}


